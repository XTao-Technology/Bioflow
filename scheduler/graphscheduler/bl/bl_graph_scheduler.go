/* 
 Copyright (c) 2018 XTAO technology <www.xtaotech.com>
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.
 
  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGE.
*/
package bl

import (
    "errors"

    . "github.com/xtao/bioflow/message"
    . "github.com/xtao/bioflow/common"
    . "github.com/xtao/bioflow/scheduler/common"
)


/*
 * Scheduler for bpipe-like DSL. It is responsible for triggering
 * build and execute the graph generated by bpipe like pipeline.
 */
type blGraphScheduler struct {
    /*
     * Graph builder state
     */
    graphBuilder GraphBuilder
    flowGraph Graph
    flowGraphCompleted bool

    /*
     * Hold the context information for the graph builder
     */
    job Job
    pipeline Pipeline
}

func (blScheduler *blGraphScheduler)_Graph() Graph {
    return blScheduler.flowGraph
}

func (blScheduler *blGraphScheduler) GetStageByID(stageId string) Stage {
    node := blScheduler._Graph().GetNode(StringID(stageId))
    if node == nil {
        return nil
    } else {
        return node.Stage()
    }
}

/* Build flow graph via bl graph builder */
func (blScheduler *blGraphScheduler) BuildGraph() (error, *BuildStageErrorInfo) {
    var buildStageErrInfo *BuildStageErrorInfo
    var err error = nil
    /*
     * During its lifetime, job may build flow graph several times.
     * When it hits a item (e.g, ShardFiles) in pipeline whose data
     * is not ready and depend on previous stage. It will suspend 
     * the graph build process and start execute the partial graph.
     * when the partial graph is completed, it will calls the routine
     * again to continue build the remaining flow graph.
     * so the flow graph builder context need be saved.
     */
    if blScheduler.graphBuilder == nil {
        builder := NewBLGraphBuilder()
        err, blScheduler.flowGraph, buildStageErrInfo = builder.BuildJobFlowGraph(blScheduler.job,
            blScheduler.pipeline)
        if err == GB_ERR_SUSPEND_BUILD {
            blScheduler.graphBuilder = builder
            blScheduler.flowGraphCompleted = false
        } else {
            blScheduler.flowGraphCompleted = true
        }
    } else {
        err, buildStageErrInfo = blScheduler.graphBuilder.ResumeBuildJobFlowGraph()
        if err == GB_ERR_SUSPEND_BUILD {
            blScheduler.flowGraphCompleted = false
        } else {
            blScheduler.graphBuilder = nil
            blScheduler.flowGraphCompleted = true
        }
    }

    return err, buildStageErrInfo
}

func (blScheduler *blGraphScheduler) GetGraphInfo() (error, FlowGraphInfo) {
    info := NewBlFlowGraphInfo()
    if blScheduler.graphBuilder != nil {
        blScheduler.graphBuilder.GetGraphBuildInfo(info)
    } else {
        info.Completed = true
    }

    return nil, info
}

func (blScheduler *blGraphScheduler) CompareGraphInfoTree(infoTree *BlGraphInfoTree,
    curInfoTree *BlGraphInfoTree) (error, bool, *BuildStageErrorInfo) {
    err, inSamePos := blScheduler._CompareGraphInfoTree(infoTree, curInfoTree)
    if err != nil {
        return err, false, nil
    } else {
        if inSamePos {
            return nil, true, nil
        } else {
            err, buildStageErrInfo := blScheduler.BuildGraph()
            if err != nil && err != GB_ERR_SUSPEND_BUILD {
                SchedulerLogger.Errorf("Can't build flow graph when restoring it: %s\n",
                    err.Error())
                return err, false, buildStageErrInfo
            }
            return nil, false, nil
        }
    }
}

func (blScheduler *blGraphScheduler) _CompareGraphInfoTree(infoTree *BlGraphInfoTree,
    curInfoTree *BlGraphInfoTree) (error, bool) {
    job := blScheduler.job
    if infoTree.BranchItemPos < curInfoTree.BranchItemPos {
        SchedulerLogger.Errorf("Job %s flow graph invalid: %d/%d\n",
            job.GetID(), infoTree.BranchItemPos, curInfoTree.BranchItemPos)
        return errors.New("Invalid job flow graph state"), false
    } else if infoTree.BranchItemPos > curInfoTree.BranchItemPos {
        SchedulerLogger.Infof("Restore job %s flow graph (item %d) to item %d\n",
            job.GetID(), infoTree.BranchItemPos, curInfoTree.BranchItemPos)
        return nil, false
    } else {
        if len(infoTree.BlGraphInfoTree) != len(curInfoTree.BlGraphInfoTree) {
            return errors.New("Invalid job flow graph tree lenth"), false
        }
        for i := 0; i < len(infoTree.BlGraphInfoTree); i ++ {
            graphInfo := infoTree.BlGraphInfoTree[i]
            curGraphInfo := curInfoTree.BlGraphInfoTree[i]
            if infoTree.Complete && curInfoTree.Complete {
                continue
            }
            err, flow := blScheduler._CompareGraphInfoTree(graphInfo, curGraphInfo)
            if err != nil {
                return err, false
            } else {
                if flow {
                    continue
                } else {
                    return nil, false
                }
            }
        }
        SchedulerLogger.Infof("Job %s Flow graph pos: %d already restored to latest\n",
            job.GetID(), curInfoTree.BranchItemPos)
        return nil, true
    }
}
/*
 * Just restore the flow graph one step.
 * The reason that can't restored to latest graph is that some
 * stage may have some execution state (e.g, retry-count). We need
 * restore the execution state before restoring to a later state.
 *
 * Important !!!!
 * Don't modify the function unless truly understand the whole
 * graph recover details
 */
func (blScheduler *blGraphScheduler) RestoreGraph(info FlowGraphInfo) (error, bool, *BuildStageErrorInfo) {
    /*If graph info tree not be new, the graph has not be build*/
    graphInfo := info.(*BlFlowGraphInfo)
    if graphInfo.GetBlGraphInfoTree() == nil {
        SchedulerLogger.Infof("Graph hasn't be build yet")
        return nil, true, nil
    }
    var buildStageErrInfo *BuildStageErrorInfo

    err, curInfo := blScheduler.GetGraphInfo()
    curGraphInfo := curInfo.(*BlFlowGraphInfo)
    job := blScheduler.job
    if err != nil {
        SchedulerLogger.Errorf("Restore flow graph error: %s\n",
            err.Error())
        return err, false, nil
    }

    if info.FlowGraphInfoCompleted() && curInfo.FlowGraphInfoCompleted() {
        SchedulerLogger.Infof("Job %s flow graph already restored to latest\n",
            job.GetID())
        return nil, true, nil
    } else if info.FlowGraphInfoCompleted() && !curInfo.FlowGraphInfoCompleted() {
        SchedulerLogger.Infof("Restore job %s flow graph to complete\n",
            job.GetID())
        err, buildStageErrInfo = blScheduler.BuildGraph()
        if err != nil && err != GB_ERR_SUSPEND_BUILD {
            SchedulerLogger.Errorf("Can't build flow graph when restoring it: %s\n",
                err.Error())
            return err, false, buildStageErrInfo
        }
        return nil, false, nil
    } else if !info.FlowGraphInfoCompleted() && curInfo.FlowGraphInfoCompleted() {
        SchedulerLogger.Errorf("job %s Current flow graph is newer, strange error\n",
            job.GetID())
        return errors.New("Current graph is newer"), false, nil
    } else if !info.FlowGraphInfoCompleted() && !curInfo.FlowGraphInfoCompleted() {
        return blScheduler.CompareGraphInfoTree(graphInfo.GetBlGraphInfoTree(), curGraphInfo.GetBlGraphInfoTree())
    }

    return nil, false, nil
}

/*
 * Whether job's flow graph is built complete
 */
func (blScheduler *blGraphScheduler) GraphCompleted() bool {
    return blScheduler.flowGraphCompleted
}

func (blScheduler *blGraphScheduler) CheckGraphState() int {
    /*
     * It check graph nodes state by issuing a schedule operation,
     * but doesn't mark nodes state which indicate that the node
     * is not really scheduled.
     */
    _, ret, _ := blScheduler._try_schedule_ready_nodes(true)
    return ret
}

func (blScheduler *blGraphScheduler) Fini() error {
    return nil
}

func (blScheduler *blGraphScheduler) Schedule() (map[string]Stage, int, error) {
    return blScheduler._try_schedule_ready_nodes(false)
}

/*
 * The graph state check and schedule interfaces all call this routine. So a parameter
 * is provided to differentiate these two cases:
 * 1) check graph state: it doesn't issue ready nodes/stages to scheduler, so shouldn't
 *    change ready nodes state to "SCHEDULING"
 * 2) schedule graph: it mark all the found ready nodes to "SCHEDULING" and issue the stages
 *    to scheduler.
 */
func (blScheduler *blGraphScheduler) _try_schedule_ready_nodes(checkOnly bool) (map[string]Stage, int, error) {
    /*
      Find a stage not depending on any other pending stages, 
      the stages should be executed in the topological sorting order
     */
     job := blScheduler.job
     graph := blScheduler._Graph()
     stage_map := make(map[string]Stage)
     nmap, ret := graph.FindReadyNodes(!checkOnly)
     if ret == 1 {
         SchedulerLogger.Infof("job %s complete \n", job.GetID())
         return stage_map, JOB_GRAPH_FINISHED, nil
     } else if ret == 2 {
         SchedulerLogger.Infof("try_schedule_ready_nodes(job %s): completed with nodes forbidden\n",
             job.GetID())
         return stage_map, JOB_GRAPH_PSEUDO_FINISH, nil
     } else {
         if len(nmap) == 0 {
            /*job is pending*/
            SchedulerLogger.Debugf("try_schedule_ready_nodes(job %s): no ready stages\n",
                job.GetID())
            return stage_map, JOB_GRAPH_NOBUILD, nil
         } else {
            /*try to schedule some stage*/
            readyStageIds := ""
            for _, nd := range nmap {
                var stage = nd.Stage()
                if readyStageIds != "" {
                    readyStageIds += ","
                }
                readyStageIds += stage.GetID()
                stage_map[stage.GetID()] = stage
            }
            SchedulerLogger.Debugf("try_schedule_ready_nodes(job %s): ready stages %s\n",
                job.GetID(), readyStageIds)
         }
     }

     return stage_map, JOB_GRAPH_PENDING, nil
}

func (blScheduler *blGraphScheduler)HandleGraphEvent(stageId string, event GraphEvent) error {
    graph := blScheduler._Graph()
    job := blScheduler.job
    node := graph.GetNode(StringID(stageId))
    if node == nil {
        SchedulerLogger.Infof("HandleBLGraphEvent(job %s, stage %s): ignore non-exist node event\n",
            job.GetID(), stageId)
        return errors.New("Invalid stage id for graph scheduler")
    }

    switch event {
        case GRAPH_EVENT_DONE:
            node.SetState(NODE_STATE_COMPLETE)
        case GRAPH_EVENT_FORBIDDEN:
            node.SetState(NODE_STATE_FORBIDDEN)
            graph.MarkNodesForbiddenState()
        case GRAPH_EVENT_FAIL:
            node.SetState(NODE_STATE_FAIL)
        case GRAPH_EVENT_RUNNING:
            node.SetState(NODE_STATE_PENDING)
        case GRAPH_EVENT_SUBMITTED:
            node.SetState(NODE_STATE_PENDING)
        case GRAPH_EVENT_SUBMIT_FAIL:
            /*
             * Before scheduled, the node have been marked SCHEDULING,
             * so should restore its state here
             */
            node.SetState(NODE_STATE_INITIAL)
        case GRAPH_EVENT_LOST:
            node.SetState(NODE_STATE_LOST)
		case GRAPH_EVENT_QUEUED:
            node.SetState(NODE_STATE_PENDING)
        default:
            SchedulerLogger.Infof("HandleBlGraphEvent(job %s, stage %s): ignore graph event event %s\n",
                job.GetID(), stageId, event.String())
    }

    return nil
}

func (blScheduler *blGraphScheduler) StageCount() int {
    graph := blScheduler._Graph()
    if graph == nil {
        return -1
    }
    return graph.GetNodeCount()
}

func (blScheduler *blGraphScheduler) GetWaitingStages() ([]Stage, []Stage) {
     if blScheduler._Graph() == nil {
         return nil, nil
     }

     waitingNodes, forbiddenNodes := blScheduler._Graph().FindWaitingNodes()
     waitingStages := make([]Stage, 0)
     for _, node := range waitingNodes {
         waitingStages = append(waitingStages, node.Stage())
     }

     forbiddenStages := make([]Stage, 0)
     for _, node := range forbiddenNodes {
         forbiddenStages = append(forbiddenStages, node.Stage())
    }

     return waitingStages, forbiddenStages
}

func (blScheduler *blGraphScheduler) GetOutput() (*JobOutput, error) {
    return nil, nil
}

func NewBlGraphScheduler(job Job, pipeline Pipeline) *blGraphScheduler {
    return &blGraphScheduler{job: job, pipeline: pipeline}
}
